---
description: An implementation of coroutines in pure Java
---

# Coroutine Details

## A Coroutine Implementation for Java

The coroutines project provides a pure Java implementation of cooperative concurrency, also known as coroutines. Coroutines implement lightweight multiprocessing where all running coroutines share the available execution threads, shortly suspending execution between processing steps to give other coroutines the chance to execute. Furthermore coroutines can suspend their execution indefinitely when waiting for other coroutines or external resources \(e.g. data to be sent or received\), giving other code the chance to use the available threads.

To achieve this functionality, the implementation makes use of several modern Java features of which some are available starting with Java 8. The execution of coroutine steps is implemented by means of CompletableFuture which in turn runs the code by default in the {@link ForkJoinPool\#commonPool\(\) common thread pool} defined in the {@link ForkJoinPool} class. But if needed the {@link Executor} used for running coroutines can be changed.

To provide a fluent and readable declaration the API makes extensive use of the new functional programming features of Java and the \(recommended\) use of static imports. By using these, especially by applying lambda expressions and method references, a concise and easily understandable declaration of coroutines is possible.

From the outside a coroutine is a function that receives an input value, processes it, and return an output value as the result of the execution. This is similar to the {@link Function} interface introduced with Java 8. If invoked {@link CoroutineScope\#blocking\(Coroutine\) blocking} it will behave exactly like a standard function, blocking the current thread until the processing has finished and the result value has been produced. But if invoked with {@link CoroutineScope\#async\(Coroutine\) asynchronously} the coroutine will be executed in parallel to the current thread, suspending it's execution shortly between processing steps or even pausing until data is available.

Besides this `Coroutine` class there are a few other classes that play an important role in the execution of coroutines:

* {@link CoroutineContext}: Each coroutine runs in a certain context. The context can either be provided explicitly or else the {@link Coroutines\#getDefaultContext\(\) default context} is used. If different coroutines need to communicate during their execution they need to run in the same context. The context can also be used to provide configuration for the coroutines running in it.
* {@link CoroutineScope}: Coroutines can only be launched from the inside of a scope. The scope provides the runtime environment for an arbitrary set of coroutines. It also serves as a defined entry and exit-point into coroutine executions: a scope will block execution of the creating thread until all coroutines in it have finished execution \(either successfully, by cancelation, or with an error\). This follows the patter of structured concurrency which prevents "forgotten" coroutine executions running in the background or terminating silently with an error. The scope also provides configuration and shared state for the coroutines in it, overriding the more general configuration in the context.
* {@link Continuation}: Every execution of a coroutine is associated with a continuation object that contains the current state. It is local to that execution and not shared with other running instances of the same or other coroutines.
* {@link CoroutineStep}: The base for all steps that can be executed in a coroutine. Like the coroutine itself it basically is a function that receives an input value and produces a result. When executing asynchronously a step implementation can suspend it's execution by stopping the background execution completely until the condition that caused suspension no longer exists \(e.g. data becomes available\). Several standard steps are defined in the 'step' sub-package but the base class can also be extended to create new kinds of coroutine steps.
* {@link Suspension}: If a step signals to suspend it's asynchronous execution a suspension object is created. The suspension contains the current execution state, mainly by referencing the associated {@link Continuation}. When the suspending condition is resolved it can be used to resume the asynchronous execution of the coroutine at the step after the suspension.
* {@link Channel}: The previous classes are always involved when building and executing coroutines. Channels are an optional but important feature because they allow multiple coroutines to communicate without blocking the execution thread. A coroutine will automatically suspend it's execution if a channel use to receive or send has no data or capacity available. As soon as the channel becomes available again the coroutine will continue to run. Channels are managed by either the scope or the context the coroutine runs in. If coroutines in different scopes need to communicate through a channel their scopes need to have the same context and the channel must be created in the context \(not in the scope which is the default\).

A coroutine can either be created by invoking the public {@link \#Coroutine\(CoroutineStep\) constructor} with the first {@link CoroutineStep} to execute or by invoking the factory method {@link \#first\(CoroutineStep\)}. The latter allows to declare a coroutine in a fluent way with better readability. There is a slight limitation caused by the generic type system of Java: if the result of {@link \#first\(CoroutineStep\) first\(\)} is assigned to a variable with a specific input type it may be necessary to declare the input type explicitly in the parameters of a lambda expression. For example, the following example \(using a static import of first\(\) may cause a compiler error \(depending on the Java version used\):

```java
Coroutine toUpper = first(apply(s -> s.toUpperCase()));
```

To make the code compile, the type of the lambda argument needs to be declared explicitly:

```java
Coroutine toUpper = first(apply((String s) -> s.toUpperCase()));
```

After a coroutine has been created it can be extended with additional steps by invoking the instance method {@link \#then\(CoroutineStep\)} on it. This method takes the next step to be executed and **returns a new coroutine instance**. This means that coroutines are **effectively immutable**, i.e. they cannot be modified after they have been created. Only new coroutines can be created from them. This allows to declare coroutine templates which can be extended by adding additional processing steps without the risk of changing the original. Thus the {@link \#first\(CoroutineStep\) first\(\)} and {@link \#then\(CoroutineStep\) then\(\)} methods implement a builder pattern where each invocation creates a new coroutine instance.

The immutability of coroutines only covers their "explicit" internal state. The Coroutine class also extends {@link RelatedObject} and therefore allows to set arbitrary relations on it which can be used to configure step behavior or set default data, for example. To also make the relations of an instance immutable \(to "seal" a coroutine template\) just set the flag relation {@link MetaTypes\#IMMUTABLE IMMUTABLE} on it which will prevent the further modification of relations. This will then also effect all running instances of the coroutine \(see below\).

When a coroutine is executed a copy of it is created and then associated with a new {@link Continuation} instance. That prevents running code to modify the the coroutine \(template\) it has been started from but gives it access to any of it's relations. The actual runtime state is stored in the continuation object and may be modified freely by the coroutine code. It is recommended that coroutine steps use the continuation if they need to share data with other steps besides the standard input and output parameters.

Accessing state in the continuation can be done without further synchronization because the steps in a coroutine are executed sequentially and never concurrently \(unless stated otherwise by some special step implementations\). But if steps access variables outside the continuation they must apply the same caution like other multi-threaded code in Java because access to such resource may \(and will probably\) need synchronization to avoid concurrency issues \(which are notoriously difficult to debug\). This includes {@link CoroutineScope} and {@link CoroutineContext} which are shared by multiple running coroutine instances. There are no synchronization mechanisms for access to the relations in these objects. If a step implementation wants to modify relations in the scope or context it must perform the necessary synchronization itself.

**Attention:** Any synchronization between coroutines should be applied with caution. Coroutines implement **cooperative multi-tasking** by executing their steps in a thread pool. These pools assume that the code running in a pool thread only occupies it as long as needed for the processing. Blocking such a thread in some way \(like waiting for a lock, accessing a synchronized resource, or just sleeping\) counteracts the purpose of the thread pool in particular and of cooperative multi-tasking in general.

Therefore it is strongly advised to not perform "classical" synchronizations from coroutine steps. Instead it should be checked whether it is possible to implement this in a cooperative way by suspending the coroutine execution while waiting for a resource. An example would be to perform the waiting in a separate thread \(outside of the coroutine thread pool\) and resume the coroutine when the resource becomes available. An even better way would be to use a natively asynchronous API like in the java.nio package \(see the sub-package 'step.nio' for examples\).

